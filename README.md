# SpaceAce

A fancy immutable storage library for JavaScript

## Status

No code exists yet. So far it's just a readme consisting of rough ideas that may turn into a library. Any feedback or ideas are welcome!

## Goal

To be as powerful and useful as Redux, but more modular with an easier to use API.

## Background

It's become standard practice in front-end JavaScript to have views that receive data via a one-way data flow. This was popularized by React and Flux/React. The idea is that the view components contain no state. Instead, they receive their data via properties given by parent components, which ultimately is given data from a single data store. This store's _state_ object is immutable. Instead of being changes, it's replaced with a slightly altered copy, and the new state is passed down through the components. This state is generated by a function known as a _reducer_. The reducer receives an action, and based on the action it takes the existing state and generates a new one. This new state is then passed to the view components, triggering a re-render of them.

This concept, referred to as _Flux_ has many advantages:

- It's much easier to reason through the changes your application experiences.
- You can easily log changes.
- You can even replay/undo state changes.
- Has great libraries such as _Redux_ to help you get started.

That all sounds nice but it has its problems:
- It's not clear which parts of the store are relevant to each view component.
- It's hard to architect the application code around this concept. People will put all their actions in a single `actions.js`, and end up with a giant reducer in `reducer.js`. This goes against the goal of keeping all the code relevant to a component in a single file.
- This pattern results in a lot of boilerplate code. Actions are defined in one file, referenced multiple times in the same file, and then referenced in the app reducer. It'd be nice to define an action one, and then just call it.

## Usage

SpaceStore can be used with any front-end view library, but the examples below are done with React.

**index.js**
```jsx
import react from 'react';
import ReactDOM from 'react-dom';
import Space from 'spaceace';
import Container from './Container';

// Create the root "space" along with its initial state
const rootSpace = new Space('root', { name: 'Jon', todoList: { todos: [] } });
rootSpace.actions.subscribe((space, causedBy) => {
  // Example `causedBy`s:
  // ['initialized'], ['todoList#addTodo'], ['todoList.todos[akd4a1plj]#toggleDone']
  console.log(`Re-render of <Container /> caused by ${causedBy.join(', ')}`);
  ReactDOM.render(
    <Container {...rootSpace} />,
    // ^ same as <Container state={rootSpace.state} actions={rootSpace.actions} />
    document.getElementById('react-container')
  );
});
```

**Container.js**
```jsx
import react from 'react';
import TodoList from './TodoList';

export default function Container({ state, actions }) {
  // Create/Get child space that uses/takes over `state.todoList`
  const todoListSpace = actions.fetchSpace('todoList');

  return (
    <div>
      <h1>Welcome {state.name}</h1>
      <TodoList {...todoListSpace} name={state.name} />
    </div>
   );
```

**TodoList.js**
```jsx
import react from 'react';
import Todo from 'Todo';

// state and actions auto-created for each space
export default function TodoList({ state, actions, name }) {
  const { todos } = state;

  return(
    <h2>{name}'s Todos:</h2>
    <button onClick={actions.do(addTodo)}>Add Todo</button>
    <ul className='todos'>
      {todos.map(todoSpace =>
        <Todo
          {...todoSpace}
          onRemove={actions.do(removeTodo, todoSpace)}
          key={todoSpace.state.id}
        />
      )}
    </ul>
  );
};

// Actions are given the event first, then the space
// The object that is returned replaces that space's state
function addTodo(e, { state, actions }) {
  const { todos } = state;
  const lastIndex = todos.length - 1;
  const nextId = todos[lastIndex].id + 1;

  e.preventDefault();

  return {
    todos: [
      // actions.space(…) creates a space for the todo, with an initial state
      // An update to this new space will propagate up to TodoList's space
      actions.space({ id: nextId, msg: '', done: false })
     ].concat(todos)
   };
 }

 // Note the `todoSpace` parameter passed in by `actions.do` in the render above
function removeTodo(e, todoSpace, { state }) {
  const newTodos = state.todos.filter(t => t.id !== todoSpace.state.id);

  return {
    todos: newTodos
  };
}
```

**Todo.js**
```jsx
import react from 'react';

export default function Todo({ state: todo, actions, onRemove }) {
  const doneClassName = todo.done ? 'done' : '';

  return(
    <li className='todo'>
      <input type='checkbox' checked={done} onChange={actions.do(toggleDone)} />
      <span className={doneClassName}>{todo.msg}</span>
      <button onClick={onRemove}>Remove Todo</button>
    </li>
  );
};

function toggleDone(e, { todo }) {
  return {
    // Copy of old todo, with one field changed
    todo: Object.assign({}, todo, { done: !todo.done })
  };
}
```

## Documentation

### What is a Space?

`Space` is the default class provided by the `spaceace` npm package.

Every `space` consists of:
- An immutable state, which can only be overwritten using an action.
- A method for subscribing to updates

You create a new space by calling `new Space(…)` e.g.
```javascript
"the space's name", { initialState: true, todoList: { todos: [] } }).
```

The first parameter to `Space`'s constructor is a string used to identify the space.
This name is used to bind child spaces to a particular node in the parent space's state.
It is also useful for logging the activity that occurs within the entire data store.

If you have a space (e.g. `rootSpace`), and want to create a child space, call its `space()`.
e.g. `rootSpace.space('todoList')`. This new child space will take
over the part of the parent space's state addressed by the name of the child space.
