# SuperStore

A fancy immutable storage library for JavaScript

## Status

No code exists yet. So far it's just a readme consisting of rough ideas that may turn into a library. Any feedback or ideas is welcome!

## Background

It's become standard practice in front-end JavaScript to have views that receive data via a one-way data flow. This was popularized by React and Flux/React. The idea is that the view components contain no state. Instead, they receive their data via properties given by parent components, which ultimately is given data from a single data store. This store's _state_ object is immutable. Instead of being changes, it's replaced with a slightly altered copy, and the new state is passed down through the components. This state is generated by a function known as a _reducer_. The reducer receives an action, and based on the action it takes the existing state and generates a new one. This new state is then passed to the view components, triggering a re-render of them. 

This concept, referred to as _Flux_ has many advantages: 

- It's much easier to reason through the changes your application experiences. 
- You can easily log changes.
- You can even replay/undo state changes.
- Has great libraries such as _Redux_ to help you get started.

That all sounds nice but it has its problems:
- It's not clear which parts of the store are relevant to each view component.
- It's hard to architect the application code around this concept. People will put all their actions in a single `actions.js`, and end up with a giant reducer in `reducer.js`. This goes against the goal of keeping all the code relevant to a component in a single file.
- This pattern results in a lot of boilerplate code. Actions are defined in one file, referenced multiple times in the same file, and then referenced in the app reducer. It'd be nice to define an action one, and then just call it.

## Usage

SuperStore can be used with any front-end view library, but the examples below are done with React.

**index.js**
```javascript
import react from 'react';
import ReactDOM from 'react-dom';
import SuperStore from 'super-store';
import Container from './Container';

const store = new SuperStore();
store.subscribe(() => {
  ReactDOM.render(
    <Container store={store} />,
    document.getElementById('react-container')
  );
});
```

**Container.js**
```javascript
import react from 'react';
import TodoList from './TodoList';

export default function Container({ store }) {
  return (
    <div>
      <h1>Welcome {store.state.name}</h1>
      <TodoList {...store.spaces('todos')} name={store.state.name} />
    </div>
   );
```

**TodoList.js**
```javascript
import react from 'react';
import Todo from 'Todo';

// actions and spaces auto-created for each space
export default function TodoList({ todos, actions, spaces, name }) {
  return(
    <h2>{name}'s Todos:</h2>
    <button onClick={actions.do(addTodo)}>Add Todo</button>
    <ul className='todos'>
      {todos.map(todo =>
        <Todo {...spaces(todo.id)} />
      )}
    </ul>
  );
};

function addTodo(e, { todos }) {
  const lastIndex = todos.length - 1;
  const nextId = todos[lastIndex].id + 1;
  
  e.preventDefault();
  
  return { // Overwrites the todos value on this space
    todos: [
      { id: nextId, msg: '', done: false }
     ].concat(todos)
   };
 }
```

**Todo.js**
```javascript
import react from 'react';

// actions and spaces auto-created for each space
// This component ignores spaces though, since it isn't needed
export default function Todo({ todo, actions }) {
  const doneClassName = todo.done ? 'done' : '';
  
  return(
    <li className='todo'>
      <input type='checkbox' checked={done} onChange={actions.do(toggleDone)} />
      <span className={doneClassName}>{todo.msg}</span>
      <button onClick={actions.parentDo(removeTodo, todo)}>Remove Todo</button>
    </li>
  );
};

function toggleDone(e, { todo }) {
  return {
    todo: Object.assign({}, todo, { done: !todo.done }) // Copy of old todo, with one field changed
  };
}

// Runs with the the event, whatever is passed in, and then the parent space
function removeTodo(e, todo, { todos }) {
  const newTodos = todos.filter(t => t.id !== todo.id);
  
  return { 
    todos: newTodos
  };
}
```
